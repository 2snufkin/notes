# Continuous Integration and Continuous Deployment (CI/CD) with GitHub Actions

Continuous Integration (CI) and Continuous Deployment (CD) are software development practices that aim to streamline the process of building, testing, and deploying code changes. 

## Continuous Integration (CI)

Continuous Integration is the practice of frequently integrating code changes from multiple developers into a shared repository. The primary goal of CI is to detect and address integration issues as early as possible by automatically building and testing the code whenever changes are pushed to the repository.

Benefits of CI include:
- Early detection of integration problems.
- Faster identification and resolution of bugs.
- Improved collaboration among developers.
- Consistent and automated testing procedures.

### Configuration The .yaml File
There are template for each dev langauage in this [link](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration)

#### Java example
```yaml
name: Java CI

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
      - name: Build with Maven
        run: mvn --batch-mode --update-snapshots package

```


## Continuous Deployment (CD)

Continuous Deployment is an extension of CI where code changes that pass the automated tests are automatically deployed to production or staging environments. CD aims to reduce the manual intervention required for deploying code changes, leading to faster and more reliable software releases.

Benefits of CD include:
- Reduced human error in the deployment process.
- Faster delivery of new features to users.
- Continuous feedback loop for developers.
- Consistent and repeatable deployment procedures.

## Continuous Deployment Workflow to Deploy to Azure App Service

In this section, we'll outline the steps to create a GitHub Actions workflow for deploying your application to Azure App Service. Azure App Service is a platform-as-a-service (PaaS) offering that allows you to build, deploy, and scale web apps.

### Prerequisites

Before creating the workflow, make sure you have:
- A GitHub repository containing your application code.
- An Azure account with an active App Service instance.
- Appropriate credentials and access to configure GitHub Actions and Azure.

### Creating the Workflow

1. **Create a `.github/workflows` Directory:**
   In your GitHub repository, create a directory named `.github/workflows` if it doesn't already exist. This is where you'll store your workflow configuration files.

2. **Create a Workflow Configuration File:**
   Inside the `.github/workflows` directory, create a YAML file (e.g., `deploy-to-azure.yml`) to define your workflow. Use the following structure as a starting point:

   ```yaml
   name: Deploy to Azure App Service
   on:
     push:
       branches:
         - main  # Adjust to your main branch name

   jobs:
     deploy:
       runs-on: ubuntu-latest

       steps:
         - name: Checkout Repository
           uses: actions/checkout@v2

         - name: Set up Node.js
           uses: actions/setup-node@v2
           with:
             node-version: '14'

         - name: Install Dependencies and Build
           run: |
             npm ci
             npm run build  # Adjust to your build script

         - name: Deploy to Azure
           uses: azure/webapps-deploy@v2
           with:
             app-name: <your-app-name>
             publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
   ```

3. **Configure Secrets:**
   For security, sensitive information like Azure credentials should not be directly included in the workflow file. Instead, you can use GitHub repository secrets. In your repository settings, create a secret named `AZURE_WEBAPP_PUBLISH_PROFILE` and paste your Azure App Service publish profile XML as the value.

4. **Adjust Workflow Configuration:**
   Customize the workflow configuration to match your application's build process, branch settings, and any additional requirements.

5. **Push Changes and Test:**
   Commit and push the workflow configuration file to your repository. This will trigger the workflow to run. You can monitor the progress on the "Actions" tab of your repository.

6. **Deployment Verification:**
   After the workflow completes, visit your Azure App Service to verify that the deployment was successful.

By creating and configuring this GitHub Actions workflow, you've implemented a basic CD pipeline that automatically deploys your application to Azure App Service whenever changes are pushed to the main branch. This approach simplifies the deployment process, ensures consistency, and helps you deliver features to users more efficiently. Remember to adjust the workflow according to your specific application's needs and follow best practices for secure credential handling.

# Example for a java workflow
Below is a GitHub Actions workflow YAML file that automates the build and release process for your open source project. This workflow will trigger the compilation of the project on every push to any branch and create a new release whenever a Git tag is pushed.

Save this YAML configuration as `.github/workflows/build-and-release.yml` in your repository:

```yaml
name: Build and Release

on:
  push:
    branches:
      - '*'
  push:
    tags:
      - '*'

jobs:
  build:
    name: Build Project
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2
        
      - name: Set up Java
        uses: actions/setup-java@v2
        with:
          java-version: '8'  # Adjust the Java version as needed
          
      - name: Build Project
        run: mvn clean install  # Adjust this to match your Maven build command
        
      - name: Archive Artifact
        run: zip -r artifact.zip ./target  # Adjust this to match your Maven build output directory

      - name: Upload Artifact
        uses: actions/upload-artifact@v2
        with:
          name: release-artifact
          path: artifact.zip

  release:
    name: Create Release
    needs: build
    if: startsWith(github.ref, 'refs/tags/')
    
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2
        
      - name: Download Artifact
        uses: actions/download-artifact@v2
        with:
          name: release-artifact
          path: .
          
      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          body: |
            Release created by GitHub Actions
          draft: false
          prerelease: false
          
      - name: Upload Artifact to Release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./artifact.zip
          asset_name: artifact.zip
          asset_content_type: application/zip

```

Make sure to adjust the configuration according to your project's build process, file structure, and any specific requirements you might have. This workflow will automatically compile and release your project based on the triggers you mentioned.